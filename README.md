# Детектор багов в js-коде (ml-bug-detector)

Данный проект является частью курсовой работы (2020 год)
студента 1 курса магистратуры
ОП **"Анализ больших данных в бизнесе, экономике и обществе"**
НИУ "Высшая Школа Экономики" (СПб)
по теме **"Тестирование веб-приложений с использованием машинного обучения"**

_Основная идея проекта:_ подробные (и говорящие) названия функций и аргументов заводятся
разработчиками скорее для самих же себя в будущем (для читаемости кода).
Однако эти же названия можно использовать и автоматического для поиска ошибок в коде.
За основу взят алгоритм, разработанный компанией Google на основе нейронных сетей, [Word2Vec](https://habr.com/ru/post/446530/). 
Он преобразует слова в векторное представление в зависимости от своего контекста употребления в обучающей выборке.
Изначально этот алгоритм использовался для анализа новостей, однако в данном проекте применен для анализа кода.

## Структура репозитория
- **scripts** - папка с js скриптами (это сырые данные, которые анализируем)
- **scripts-parser** - содержит код, который преобразует js скрипты из папки **scripts** в машиночитаемый формат для дальнейшего анализа
    - **ast** - Abstract Syntax Tree
    - **tokenizer** - создаёт данные-токены, чтобы после скормить их Word2Vec моделе
- **word2Vec** - содержит код для построения модели Word2Vec на python
- **shared** - вынесенные константы и ряд функций python
- **function-based-bug-detector** - применение модели Word2Vec для поиска неправильно использованных аргументов в функциях

## Подготовка окружения
В проекте используется Python и Typescript на Node.js:
- Typescript:
    - Разбиение скриптов, написанных на Javascript, на токены
    (нужны для построение Word2Vec модели)
    - Извлечение из скриптов, написанных на Javascript,
    Abstract Syntax Tree
    (нужно для применения Word2Vec модели и поиск багов)
- Python:
    - Построение Word2Vec модели и написание алгорита для её применения

**Шаги установки по typescript + nodeJS**:
- Скачать и установить [Node.js](https://nodejs.org/en/download/)
- Устновить typescript командой в консоле:
    ~~~~
    npm install -g typescript
    ~~~~
- Открыть терминал исполнить npm-команду
(для этой и всех последующих npm команд данного README использовать терминал от корня репозитория):
    ~~~~
    npm install
    ~~~~

**Шаги установки по Python**:
- установить [Python 3](https://www.python.org/downloads/)
- Открыть терминал и исполнить:
~~~~
pip3 install pandas numpy json gensim multiprocessing tqdm
~~~~

## Шаг 1. Выбор и подготовка js-файлов для парсинга
Нужно положить все интересуемые js-файлы в папку **scripts** ЛЮБОЙ вложенности
(парсер сам найдёт js-файлы, которые лежат в папке, которая в папке, что завернута в папку ...).

_Замечание_: не существует ограничения на максимальную вложенность, но существует условие на минимальную:
парсер будет ждать, что внутри **scripts** будут папки с названиями репозиториев
(это нужно в дальнейшем, чтобы не возникало конфликтов в одинаковых названиях функциях между репозиториями).
Поэтому если у вас просто много js-файлов, которые нужно проверить, без какой-либо вложенности,
то внутри папки **scripts** создайте папку с любым названием и положите туда все эти js-файлы.

В качестве примера туда сложены уже файлы некоторых репозиториев, написанных на js.

Парсер настроен таким образом, что он игнорирует директории начинающиеся с точки или с названием node_modules.

В данной работе файлы брались с 
[150k Javascript Dataset](https://www.sri.inf.ethz.ch/js150).

Вне зависимости от выбранного типа парсинга - результаты будут сложены `./data` в формате json
### Шаг 2.1. Токенизация
~~~~
npm run tokenize
~~~~
Так как это весьма ресурсозатратная операция, то скорее всего дефолтных 1.5 гига у ноды не хватит.
Для таких целей есть следующая команда (делает тоже самое, но использует больше ресурсов системы):
~~~~
npm run high-memory-tokenize
~~~~

_Результат_: разбивает код на слова (при этом проставляет каждому слову тип).
Это будет много json, с именами `tokenized-scripts_{какая-та цифра}.json`

### Шаг 2.2. Извлечение объявлений функций и их вызовы, используя AST
Через Abstract Syntax Tree из скриптов js получилось извлечь места:
- где функции объявлялись (название самой этой функции и названия аргументов этой функции)
- где функции использовались / вызывались (также названия функций и названия аргументов)

Чтобы нода взяла необработанные никак скрипты из папки `./scripts` и извлекла нужную информацию,
необходимо исполнить npm-команду:
~~~~
npm run ast-function-arguments
~~~~
также существует команда, которая даст тот же результат,
но будет использовать больше ресурсов системы
~~~~
npm run high-memory-ast-function-arguments
~~~~

_Результат_: `./data/ast-functions.json`

## Шаг 3. Word2Vec модель
Для построения данной модели нужно открыть файл `./word2Vec/buildWord2vecModel.ipynb`.

Результат выполнения данного скрипта (построенная модель) - `word2Vec/word2VecModel`
Скачать готовую модель можно здесь [по ссылке](https://drive.google.com/drive/folders/1i-3j3RkeK-taTEVkamTHydNroy36pYTy?usp=sharing)

## Шаг 4. Алгоритм по поиску неправильного использования объявленных функций
Внутри `./function-based-bug-detector` лежит блокнот в котором объяснен и реализован алгоритм по поиску
потенциально опасных моментов в использованиях функциях, объявленных разработчиков.
Он основан на предыдущем шаге 3 (использует построенную модель word2Vec).
